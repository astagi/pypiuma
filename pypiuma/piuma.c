/* This file was generated by PyBindGen 0.0.0.0 */
#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stddef.h>


#if PY_VERSION_HEX >= 0x03000000
#if PY_VERSION_HEX >= 0x03050000
typedef PyAsyncMethods* cmpfunc;
#else
typedef void* cmpfunc;
#endif
#define PyCObject_FromVoidPtr(a, b) PyCapsule_New(a, NULL, b)
#define PyCObject_AsVoidPtr(a) PyCapsule_GetPointer(a, NULL)
#define PyString_FromString(a) PyBytes_FromString(a)
#define Py_TPFLAGS_CHECKTYPES 0 /* this flag doesn't exist in python 3 */
#endif


#if     __GNUC__ > 2
# define PYBINDGEN_UNUSED(param) param __attribute__((__unused__))
#elif     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
# define PYBINDGEN_UNUSED(param) __attribute__((__unused__)) param
#else
# define PYBINDGEN_UNUSED(param) param
#endif  /* !__GNUC__ */

#ifndef _PyBindGenWrapperFlags_defined_
#define _PyBindGenWrapperFlags_defined_
typedef enum _PyBindGenWrapperFlags {
   PYBINDGEN_WRAPPER_FLAG_NONE = 0,
   PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED = (1<<0),
} PyBindGenWrapperFlags;
#endif


#include "libpiuma.h"
/* --- forward declarations --- */


extern PyTypeObject *PyPiumaError_Type;

/* --- module functions --- */



PyObject *
_Optimize(PyObject *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    struct PiumaResult retval;
    char *path;
    int width = 0;
    int height = 0;
    const char *keywords[] = {"path", "width", "height", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *)"s|ii", (char **)keywords, &path, &width, &height))
    {
        return NULL;
    }

    retval = OptimizeWrapper(path, width, height);
    if (retval.message != NULL)
    {
        PyErr_SetString(PyPiumaError_Type, retval.message);
        return NULL;
    }
    py_retval = Py_BuildValue((char *)"s", retval.path);
    return py_retval;
}


PyObject * _wrap_pypiuma_optimize(PyObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[1] = {0,};
    retval = _Optimize(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    error_list = PyList_New(1);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}
PyObject * _wrap_pypiuma_optimize(PyObject *self, PyObject *args, PyObject *kwargs);



PyObject *
_OptimizeList(PyObject *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    struct PiumaResult retval;
    PyObject *pathList;
    char **paths;
    int width = 0;
    int height = 0;

    if (!PyArg_ParseTuple(args, (char *)"O|ii", &pathList, &width, &height))
    {
        return NULL;
    }

    int pathsLen = PyObject_Length(pathList);

    paths = (char **)malloc(pathsLen * sizeof(char *));
    for (int i = 0; i < pathsLen; i++)
    {
        paths[i] = PyBytes_AS_STRING(PyUnicode_AsEncodedString((PyList_GetItem(pathList, i)), "utf-8", "~E~"));
    }
    retval = OptimizeListWrapper(paths, pathsLen, width, height);
    if (retval.message != NULL)
    {
        PyErr_SetString(PyPiumaError_Type, retval.message);
        return NULL;
    }
    Py_RETURN_NONE;
}


PyObject * _wrap_pypiuma_optimize_list(PyObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[1] = {0,};
    retval = _OptimizeList(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    error_list = PyList_New(1);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}
PyObject * _wrap_pypiuma_optimize_list(PyObject *self, PyObject *args, PyObject *kwargs);



PyObject *
_OptimizeFromDir(PyObject *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    struct PiumaResult retval;
    char *path;
    int width = 0;
    int height = 0;

    if (!PyArg_ParseTuple(args, (char *)"s|ii", &path, &width, &height))
    {
        return NULL;
    }

    retval = OptimizeFromDirWrapper(path, width, height);
    if (retval.message != NULL)
    {
        PyErr_SetString(PyPiumaError_Type, retval.message);
        return NULL;
    }
    Py_RETURN_NONE;
}


PyObject * _wrap_pypiuma_optimize_dir(PyObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[1] = {0,};
    retval = _OptimizeFromDir(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    error_list = PyList_New(1);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}
PyObject * _wrap_pypiuma_optimize_dir(PyObject *self, PyObject *args, PyObject *kwargs);

static PyMethodDef pypiuma_functions[] = {
    {(char *) "optimize", (PyCFunction) _wrap_pypiuma_optimize, METH_VARARGS|METH_KEYWORDS, NULL },
    {(char *) "optimize_list", (PyCFunction) _wrap_pypiuma_optimize_list, METH_VARARGS|METH_KEYWORDS, NULL },
    {(char *) "optimize_dir", (PyCFunction) _wrap_pypiuma_optimize_dir, METH_VARARGS|METH_KEYWORDS, NULL },
    {NULL, NULL, 0, NULL}
};
/* --- exceptions --- */


PyTypeObject *PyPiumaError_Type;

#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef pypiuma_moduledef = {
    PyModuleDef_HEAD_INIT,
    "pypiuma",
    NULL,
    -1,
    pypiuma_functions,
};
#endif


#if PY_VERSION_HEX >= 0x03000000
    #define MOD_ERROR NULL
    #define MOD_INIT(name) PyObject* PyInit_##name(void)
    #define MOD_RETURN(val) val
#else
    #define MOD_ERROR
    #define MOD_INIT(name) void init##name(void)
    #define MOD_RETURN(val)
#endif
#if defined(__cplusplus)
extern "C"
#endif
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__ ((visibility("default")))
#endif


MOD_INIT(pypiuma)
{
    PyObject *m;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&pypiuma_moduledef);
    #else
    m = Py_InitModule3((char *) "pypiuma", pypiuma_functions, NULL);
    #endif
    if (m == NULL) {
        return MOD_ERROR;
    }
    /* Register the 'PiumaError' exception */
    if ((PyPiumaError_Type = (PyTypeObject*) PyErr_NewException((char*)"pypiuma.PiumaError", NULL, NULL)) == NULL) {
        return MOD_ERROR;
    }
    Py_INCREF((PyObject *) PyPiumaError_Type);
    PyModule_AddObject(m, (char *) "PiumaError", (PyObject *) PyPiumaError_Type);
    return MOD_RETURN(m);
}
